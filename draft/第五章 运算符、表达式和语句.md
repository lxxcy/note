# 第五章 运算符、表达式和语句
[TOC]
## 基本运算符
* c用基本运算符表示算数运算
### 赋值运算符：=
* 用法：变量=符给变量的值
>注意：c中的=并非相等，而是进行赋值
>

* 效果：进行赋值，赋值行为从右往左进行
>c用可修改的左值标记那些可赋值的实体
>右值：c术语，能赋值给可修改左值的量，且本身不是左值  
>运算对象：即“项”，是运算符操作的对象  
>

* 许多语言都会回避三重赋值，但是c完全没问题，赋值的顺序是从右往左
***
### 加法运算符：+
* 用法：运算对象1+运算对象2
* 效果：将两侧的运算对象相加  
>注意：该运算对象可以是常量也可以是变量
>变量标识了可被赋值的数据对象
>但是，表达式：变量1+变量2   是一个右值
>

***
### 减法运算符：-
* 用法：运算对象1-运算对象2
* 效果：左侧的数减去右侧的数
>>+和-被称为二元运算符，即需要两个运算对象来完成操作
>>

***
### 符号运算符：-和+
* 用法：-/+运算对象
* 效果：标注或改变一个值的代数符号
>>此时的-和+是一元运算符，只需要一个运算对象
>>

***
### 乘法运算符：\*
* 用法：运算对象1\*运算对象2
* 效果：将两个值相乘
>c没有平方函数，可以使用乘法计算平方
>

***
### 除法运算符：/
* 用法：运算对象1/运算对象2
* 效果：左边的数除以右边的数（左侧的值为被除数，右侧的值为除数）
* 注意：浮点数除法的结果为**浮点数**，整数除法的结果为**整数**（c99规定，小数部分被丢弃，称为*截断*，又称*非零截断*）
>整数与浮点数的运算结果为浮点数，但是应该避免该类混合类型
>

***
## 运算符优先级
|运算符|结合律（从高到低）|
|:---|:---|
|（）|从左往右|
|++ --|从右往左|
|- +（一元）|从右往左|
|\* /|从左往右|
|+ -|从左往右|
|=|从右往左|
***
## 求值顺序
* c规定，通过优先级解决操作顺序的问题
* 当运算符共享一个运算对象时，优先级决定了求值顺序
>但是对于`int top=-(2+5)*6+(4+3*(2+3))`此类计算，优先级并未规定到底先进行哪个乘法，c将主动权留给语言的实现者
* 结合律只适用于共享同一个运算对象的运算符，例如`12/3*2`


***
## sizeof（）运算符
* 用法：sizeof 变量名      或者    sizeof(类型名)
>如果运算对象是类型，则必须用圆括号扩起来
>

* 效果：该运算符以**字节**为单位返回运算对象的**大小**
* 返回类型：size_t类型
>这是一个无符号整形
>

* 转换说明：%zd
>%zd转换说明还用于printf（）显示size_t类型（c99），如果系统不支持%zd，可使用%u或者%lu代替
>

>高级数据特性：c有一个typedef机制，允许程序员为现有类型创建别名，如`typedef double real`，此real可作为double类型的别名
>

***
## 求模运算符：%
* 用法：运算对象1%运算对象2
* 效果：给出左侧整数除以右侧整数的余数
* 注意：求模运算符**只能用于整数**，不能用于浮点数
>该运算符常用于控制程序流
>

* 如果第1个运算对象是负数，求模结果也是负数，第一个为正数则求模结果为正
>实际上，标准规定：只要a、b为整数，就可以通过`a-（a/b）*b`来计算a%b
>

***
## 递增运算符于递减运算符：++与——
* 用法：++运算对象  或  运算对象++      ——运算对象  或者  运算对象——
* 效果：前缀模式…先递增/递减再使用  后缀模式…先使用再递增/递减
>如果使用前缀模式和后缀模式会对代码产生不同的影响，最明智的做法是不要那样使用它们
>

* 优先级：很高，只有圆括号的优先级比它们高
>不要自作聪明，如果一次使用太多递增运算符，自己都会糊涂
>

* 应遵循以下规则：
	1.如果一个变量出现在一个函数的多个参数中，不要使用递增/递减运算符
	2.如果一个变量多次出现在一个表达式中，不要对该变量使用递增/递减运算符
***
## 表达式
* 组成：运算符和运算对象（一些表达式可以由*子表达式*组成）
>运算对象可以是常量、变量或者二者的结合
>

* 重要特性：**每个表达式都有一个值**
***
## 语句
* c基本程序步骤由语句组成，大多数语句由表达式构成
	一条语句相当于一条完整的计算机指令
>并不是所有的指令都是语句
>

* 规则：大部分语句都以**分号**结尾
* 效果：语句可以改变值或者调用函数，甚至可以没有操作（空语句）
* 注意：声明并非表达式语句
***
## 副作用和序列点
*副作用*：对数据对象或文件的修改
*序列点*：程序执行的点，在该点上，所有的副作用都在进入下一步之前发生
	* 分号标明了一个序列点
	* 任何一个完整表达式的结束也是序列点
>*完整表达式*：即此表达式不是另一个更大表达式的子表达式
>

***
## 复合语句（块）
*复合语句*：用**花括号**括起来的一条或多条语句，又称*块*
整个复合语句被视为一条语句执行
>风格提示：缩进于对编译器不起作用，使用缩进只是为了给读者指明程序的结构
>

***
## 类型转换
* c基本类型转换规则：
	1.类型转换出现在表达式时，unsigned char、signed char和short会被自动转换为int，如有必要会被转换成unsigned int.
	该过程被称为*升级*：从较小的类型转换成较大的类型
	2.涉及两种类型的运算，两个值会被分别转换成两种类型的更高级别
	3.类型级别从低到高：long double、double、float、unsigned long long、unsigned long、long、unsigned int、int
	>也有例外，比如，long于int大小相同时，unsigned int比long级别高
	>

	4.赋值表达式语句中，计算的最终结果会被转换成被赋值变量的类型，该过程可能导致类型升级或*降级*
	5.作为参数传递时，char和short被转换成int，float被转换成double
* 类型升级一般没有问题，类型降级会导致真正的问题…较低的类型可能放不下整个数字
* 待转换类型和目标类型不匹配时的规则：
	1.目标类型为无符号整形，且待赋值的值是整数时，额外的位将会被忽略
	2.目标类型时有符号整型，待赋值为整数，结果因实现而异
	3.目标类型为整型，待赋值为浮点数，该行为是**未定义**的
>浮点类型被降级为整数类型时，原来的符点值会被截断
>

>通常，应该避免自动类型转换，尤其是降级
>

***
## 强制类型转换运算符
圆括号和它括起来的类型名即为*强制类型转换符*
用法：（类型名）运算对象
>一般而言，不应使用混合类型，但是偶尔这样做也是有用的。语言的原则是避免给程序员设置障碍，但是程序员必须承担使用的风险和责任
>

