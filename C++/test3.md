# C++核心编程
[TOC]

## [内存四区](#c++核心编程)

* **代码区**——共享 只读
* **全局区**
* **栈区**
  特别注意：不要随便返回和利用栈区的地址
  （有的编译器可能会对返回的栈区地址上的数据做一次保留，但实际上该地址在退出函数后，应该已经被清理）
* **堆区**
    由程序员分配和释放，若程序员不释放，程序结束时将由OS回收
    在C++中主要由new在堆区开辟内存
## [new和delete](#c++核心编程)
```c++
//new用于动态申请内存，并创建了一个对象
//new返回一个相应内存的指针
data-type *data=new data-type;  //此处data-type表示一个数据类型
data-type *data2=new data-type(val);//括号是可选内容，用于给新申请的内存赋值
data-type *data3=new data-type[10];//中括号表示分配一个数组，并返回数组的首地址

//如果自由存储区已被用完，可能无法成功分配内存。所以建议检查new运算符是否返回 NULL 指针

//delete后接一个指针，用于释放new申请的内存
delete data2;
```

## [引用](#c++核心编程)
作用：给变量起别名
语法：`数据类型 &别名 = 原名`
注意：
1. 引用必须要初始化(函数中的引用形参不需要初始化，初始化是在函数调用时完成的)
2. 引用初始化后，不能更改
```c++
int a=10;
int &b=a; //此时b即作为a的别名
          //若对b进行修改，实际上就是对a进行修改
//注意：
//    1.引用必须要初始化(函数中的引用形参不需要初始化，初始化是在函数调用时完成的)
//    2.引用初始化后，不能更改
int c=20;
b=c;//赋值操作，不是修改引用，引用不能修改
```
函数形参中利用引用参数可以实现和按地址传递一样的效果
```c++
void swap(int &a,int &b){ //利用引用作为形参，可实现对传入的原数据进行修改
  int temp=a;
  a=b;
  b=temp;
}
```
引用做函数的返回值
* 不要返回局部变量的引用
* 引用类型的返回值可以作为左值(即函数要做左值，则必须返回引用)
```c++
int &swap(){
  static int temp=10;//使用static是为了使temp成为静态变量而非局部变量
  return temp;
}

int main(void){
  swap()=1000;//实际作用是将temp修改为1000
}

```
C++引用的实质，就是**指针常量**
补：const在指针中的应用
```c++
int b;
const int *a=&b;  //const在数据类型前，表示"常量指针"，该指针指向的位置可以修改，但指向位置的值不可通过该指针修改
int * const c=&b;  //const在*后，表示"指针常量"，该指针指向的位置不可修改，但指向位置的值可以通过该指针修改
```
* 常量引用
```c++
//int &val=10;  //10是存放于常量区的数据，引用本身需要一个合法空间，故该行错误

const int &val=10;  //该行却能正确编译，因为加入const后，编译器将进行优化，
                    //相当于int temp=10;const int &val=temp;

void print(const int &a){   //形参中使用const关键字，可防止函数中对引用的值进行修改
  cout <<"a=" << a << endl;
}
```

## [函数提高](#c++核心编程)
### 函数默认参数
* C++允许函数形参列表中是有默认值的
* 注意事项：
  1. 如果某个位置的参数有默认值，则该参数后面的所有参数都必须有默认值
  2. 函数声明和函数定义(函数实现)中，只允许有一个出现参数默认值

```c++
int add(int a,int b,int c);

int add(int a,int b=20,int c=30){
  return a+b+c;
}
```

### 函数占位参数
* C++允许形参列表中有占位参数，用来占位，调用函数时，必须填补该位置
* 语法：返回值类型 函数名(数据类型)
```c++
int func(int a,int){
  ......
}

int func2(int a,int =10){ //占位参数也可以有默认参数
  ......
}
```
### 函数重载
作用：函数名可以相同，提高复用性

函数重载满足条件：
  1. 同一作用域下
  2. 函数名称相同
  3. 函数参数类型不同，或者个数不同，或者顺序不同


注意： 函数返回值不可作为函数重载的条件
```c++
void func(int a,int  b){
  cout << "func(int a,int b)" << endl;
}

void func(){
  cout << "func()" << endl;
}

void func(double a,int b){
  cout << "func(double a,int b)" << endl;
}
```
引用参数也可以作为重载条件，且对于const和非const的修饰的引用参数也能进行区分

避免函数重载碰到**函数默认参数**，可能在调用时产生歧义，导致编译器报错

## [类和对象](#)
C++面向对象三大特性：**封装**、**继承**、**多态**
C++认为万事万物皆为对象，对象上有其**属性**和**行为**
具有相同性质的**对象**，可抽象为**类**
### 封装
意义：
* 将属性和行为作为一个整体，表现生活中的事物
* 将属性和行为加以权限控制

语法：
`class 别名{访问权限: 属性; 行为;};  `
`//注意和结构体定义类似，最后有一个分号`

注意事项：
1. 可通过行为，给属性赋值
2. 类中的属性和行为统称**成员**
   属性=成员属性=成员变量
   行为=成员函数=成员方法

权限：
* `public:`
  公共权限，类内可访问，类外也可访问
* `protected:`
  保护权限，类内可访问，类外**不**可访问，可继承
* `private:`
  私有权限，类内可访问，类外**不**可访问，**不**可继承

class和struct的唯一区别——**默认访问权限不同**
* class 默认访问权限为**私有**
* struct默认访问权限为**公有**

成员属性设为私有的好处：
1. 将所有成员属性设为私有，可以自己控制读写权限
   Tips：通常会再设置权限为public的公共接口来让外界修改私有成员属性
2. 对于写权限，我们可以检测数据的有效性
