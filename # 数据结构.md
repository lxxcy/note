# 数据结构
[TOC]
## 数据结构可视化练习网站
https://www.cs.usfca.edu/~galles/visualization/Algorithms.html
## 绪论
### 基本概念与术语
* 数据
    * 数据对象：相同性质的数据元素的集合
        * 数据元素：数据的基本单位
            * 数据项：不可分割的最小单位
    * 数据结构：存在特定关系的数据元素的集合
        * 数据结构三要素
            * 逻辑结构
                * 集合
                * 线性结构
                    * 一对一
                * 树形结构
                    * 一对多
                * 图状结构或网状结构
                    * 多对多
            * 数据运算
            * 物理结构（存储结构）
                * 顺序存储
                * 链式存储
                * 索引存储
                * 散列存储
    * 数据类型
        * 原子类型
        * 结构类型
    * 抽象数据类型
### 算法
* 什么是算法
    * 程序=数据结构+算法
        * 对特定问题求解步骤的一种描述，是指令的有限序列
* 特点：
    1. 有穷性
    2. 确定性
    3. 可行性
    4. 输入
    5. 输出
* 算法设计要求
    1. 正确性
    2. 可读性
    3. 健壮性
    4. 高效率与低存储量需求

### 时间复杂度与空间复杂度
* 如何计算
    1. 找到一个基本操作（最深层循环）
    2. 分析该基本操作的执行次数x与问题规模n的关系x=f(n)
    3. x的数量级O(x)就是算法的时间复杂度T(n)
* 常用技巧
    * 加法规则
    * 乘法规则
    * 
* 三种复杂度
    * 最坏时间复杂度
    * 平均时间复杂度
    * 最好时间复杂度

## 线性表
### 顺序表（顺序存储）
#### 顺序表定义
> 顺序表的实现——静态分配

```c
    #define MaxSize 10              //线性表的最大长度
    typedef struct{
        ElemType data[MaxSize];     //使用静态数组存放数据
        int length;                 //顺序表当前长度
    }SqList;                        //顺序表
```
* Tips：
  * 创建一个顺序表时，最好初始化其内部数据（以免输出遗留的数据）
  * 查询、输出操作不应超过**当前长度**，而不是最大长度
  * 声明一个结构时，并未为该结构创建相应的存储空间，仅当创建结构时才为其分配存储空间

> 顺序表的实现——动态分配

```c
    //顺序表主体
    #define InitSize 10     //默认最大长度
    typedef struct{
        int *data;          //接受动态分配数组的指针
        int MaxSize;        //最大长度
        int length;         //当前长度
    }SeqList;

    //初始化操作，动态申请内存空间的操作放于初始化中
    void InitList(Seqlist &L){
        L.data=(int *)malloc(InitSize*sizeof(int));     //使用malloc函数申请连续存储空间
        L.length=0;
        L.MaxSize=InitSize;
    }

    //增加动态数组的长度
    void IncreaseSize(SeqList &L,int len){
        int *p=L.data;
        L.data=(int *)malloc((L.MaxSize+len)*sizeof(int));  //申请一个增加地址后，最大长度的线性表应占的空间
        for(int i=0;i<L.length;i++){                        //将原数据复制到新区域
            L.data[i]=p[i];
        }
        L.Maxsize=L.MaxSize+len;                            //修改最大长度
        free(p);                                            //释放原空间
    }
```
* Tips：malloc与free函数的声明位于<stdlib.h>头文件中
#### 顺序表基本操作
> 顺序表基本操作——插入(基于静态分配)

```c
    bool ListInsert(SqList &L,int i,int e){     //在第i个位置插入元素（注意数组下标从0开始，而i最小值为1），e为待插入的数据
        
        //提高算法健壮性，将函数范围值设置为bool类型
        if(i<1 || i>L.length)                   //判断i的范围是否有效
            return false;
        if(L.length>=Maxsize)                   //存储空间已满时，不能插入
            return false;


        //算法主体
        for(int j=L.length;i=<j;i--){           //当i==j时，如果进入循环，可使数组第j个元素L.data[j-1]往后挪一位，故i==j为循环终止前的最后一个条件，i<j时，不应再执行循环
            L.data[j]=L.data[j-1]；             //将第j个元素往后挪一位
        }
        L.data[i-1]=e;                          //修改第i位数据
        L.length++;

        return true;
    }
```
> 顺序表基本操作——删除（基于静态分配）

```c
    //特别注意，哪些参数需要加引用类型？（即需要修改原实参）
    bool ListDelete(SeqList &L,int i,int &e){   //删除第i个位置的元素，e为返回的第i个元素的数据
    
    //提高算法健壮性，将函数范围值设置为bool类型
    if(i<1||i>L.length)                         //判断i的范围是否有效
        return false;


    //算法主体
    e=L.data[i-1];                              //用e接收当前第i位的数据
    for(int j=i;L.length=>j;j++)                //当j==L.length时，此时代表的元素为第j+1位，即大于length时，不应再执行循环
        L.data[j-1]=L.data[j];                  //将第j位向前挪一位
    L.length--;
    
    return ture;
    }
```

> 顺序表基本操作——按位查找

```c
    ElemType GetElem(SeqLisr L,int i)   //传入顺序表L，i为待查找的第i位
    {
        return L.data[i-1];
    }
```

> 顺序表基本操作——按值查找

```c
    int GetElem(SeqList L,ElemType e)   //传入顺序表L，e为待查找数据
    {
        for(i=1;i=<L.length;i++)        //i从1开始，当i==L.length时表示i已经到最后一个元素，i++后不应再进入循环
        {
            if(L.length[i-1]==e)
                return i;               //注意此i表示是数组第i个元素，即下标为i-1的元素
            
        }
    }

    //注意c中不允许直接使用逻辑运算符比较两个结构类型或指针类型的变量
```

### 链表（链式存储）
#### 单链表定义 
> 单链表定义
```c
    typedef struct LNode{       //用LNode标识该结构体
        Elemtype data;          //数据域
        struct LNode *next;     //声明一个指向下一个结点的指针（该指针指向一个LNode类型的结构）
    }LNode,*LinkList; 
    /*使用typedef关键字将LNode类型的结构命名为LNode，同时，也表示将LNode类型的结构类型命名为LinkList的指针类型*/
    /*此处对一个类型的结构使用不同的命名:
      LNode主要表示申请的为指向结点的指针，
      而LinkList表示想要申请一个指向头结点的指针（即代表一个单链表）*/
```

* typedef关键字的使用
```c
    //使用typedef关键字后下面两种方式等价于strut LNode *L
    LNode *L；  //表示声明一个指向单链表第一个结点的指针
    LinkList L；//表示声明一个指向单链表第一个结点的指针
```

#### 单链表基本操作
> 初始化单链表（不带头节点）
```c
    LinkList L;             //声明一个名为L的指针，该指针指向一个单链表

    bool InitList(LinkList *L)  //初始化链表
    {
        L=NULL;                 //第一个结点即能存储数据，不用头结点
        return true;
    }
```

> 初始化单链表（带头结点）
```c
    LinkList L;             //声明一个名为L的指针，该指针指向一个单链表

    bool InitList(LinkList &L)
    {
        L=(LNode *)malloc(sizeof(LNode));   //为头结点申请存储空间，头结点不存储数据
        if(L==NULL)                         //内存不足时，头结点分配失败
            return false; 
        L->next=NULL;                       //头结点的下一个结点为存储数据的第一个结点
        return true;
    }
```
* 思考：为什么此处要为L申请存储空间，而有时候申请的指向结构的指针不需要申请内存：
  * 声明一个指向结构体的指针只是表示了该指针指向某个类型的结构，并未指明其具体指向哪里
  * 初始化单链表、插入结点时，要存入数据，需要实实在在的存储空间
  * malloc函数返回申请内存的指针，该指针值可赋给指向该种类型结构的指针

> 判空操作（判断链表是否为空，主要看第一个存储数据的指针是否为空指针）
```c
    LinkList L;             //声明一个名为L的指针，该指针指向一个单链表

//不带头结点的单链表判空
    bool Empty(LinkList L)
    {
        if(L==NULL)         //第一个结点即可存储数据，故第一个结点为空的是空链表
            return true;
        else
            return false;
    }

//带头结点的单链表判空
    bool Empty(LinkList L)
    {
        if(L->next==NULL)   //第一个结点为头结点，头结点不存储任何数据，故下一个结点为空才的才为空链表
            return true;
        else
            return false;
    }
```
> 插入
* Tips：插入操作分**前插**和**后插**（最常用）
```c
    #include <stdlib.h>                 //包含malloc与free函数的头文件
    LinkList L;


//带头结点的单链表插入（后插操作）
    bool ListInsert(LinkList &L,int i,ElemType e)   //传入单链表L，i为待插入的位置，e为待插入的数据
    {
        if(i<1)             //处理错误的i值
            return false;

        //算法主体
        int j=0;                                    
        LNode *p=L;                                 //p代表
        while(p!=NULL && j<i-1)                    //对p判断是否为空指针以防止超过最后一个结点，j=i-1时表示已经到达结点i-1（注意头结点为0号），故超过该结点不应再进入循环
        {
            p=p->next;
            j++;
        }
        if(p==NULL)                                 //i的值超过结点长度，应报错
            return false;
        LNode *s=(LNode *)malloc(sizeof(LNode));    //为新数据创建一个结点，特别注意：别忘了为该节点分配存储空间
        s->data=e;                                  //存储新数据
        s->next=p->next;                            //让新结点指向p的下一个结点
        p->next=s;                                  //让p指向新结点

        return true;                                //插入成功
    }
    

//不带头结点的单链表插入
    bool ListInsert(LinkList &L,int i,ElemType e)
    {
        if(i<1)
            return false;
        
        if(i==1)                                    //插入第1个结点的操作与其他结点不同（此操作使用前插
        {
            LNode *s=(LNode *)malloc(sizeof(LNode));
            s->data=e;
            s->next=L;                              //让s指向原来的第一个结点
            L=s;                                    //修改单链表的第一个结点为S
        }

        LNode *p=L;                                 //对于插入非第一个结点，采用后插操作
        int j=1;                                    //默认让头结点为0号，由于无头结点，故从1开始
        while(p!=NULL && j<i-1)
        {
            p=p->next;
            j++;
        }
        LNode *s=(LNode *)malloc(sizeof(LNode));
        s->data=e;
        s->next=p->next;
        p->next=s;

        return true;
    }

//后插操作
    bool InsertNextNode(LNode *p,ElemType e)
    {
        if(p==NULL)                             //内存分配失败、传入的p不合法（为NULL）的处理
            return false;
        LNode *s=(LNode *)malloc(sizeof(LNode));
        s->data=e;
        s->next=p->next;
        p->next=s;

        return true;
    }

//前插操作有两种实现方式
//1.0传入一个头结点，循环查找p的前驱q，再调用后插操作函数于q后插入新结点
    bool InertPriorNode(LinkList L,LNode *p,ElemType e)

//2.0将待插入位置的结点的数据挪给新结点，再将新结点插入其后面，最后将新数据存入待插入结点（相当于以另一种方式实现了前插）
    bool InsertPriorNode(LNode *p,Elemtype e)
    {
        LNode* s=(LNode *)malloc(sizeof(LNode));
        s->data=p->data;        //将p的数据往后挪给s
        p->data=e;              //将e存到p中
        s->next=p->next;        //将p后面的结点连到s后面
        p->next=s;              //将s连到p后面

        return true;
    }
```

> 删除
* 按位序删除（带头结点的单链表）
```c
    bool ListDelete(LinkList &L,int i,ElemType &e)  //传入链表头指针（引用类型，传入需要删除的结点位序i（即结点i，第i+1个结点），e为写回的数据
    {
        if(i<1)
            return false;
        
        LNode *p,* q;               //p为当前正扫描的结点
        p=L;
        int j=0;                    //j表示当前p指向的是第几个结点（头结点为结点0，不算入结点位序）
        while(p!=NULL && j<i-1)     //当j==i-1时，表示p已经指向结点i-1，此节点即为结点i的前驱结点，故此时不应再进入循环
        {
            p=p->next;              //将p指向下一个结点
            j++;                    //此时表示p指向了结点j
        }
        if(p==NULL)                 //注意判断的是结点i-1后有无其他结点
            return false;
        
        q=p->next;                  //q为p的下一个结点，即第结点i
        e=q->data;                  //将q的数据写入e
        p->next=q->next;            //将q的后继结点接到p后面
        free(q);                    //删除q结点（结点i）
        return true;
    }
```
* 按指定结点删除（带头结点的单链表）
```c
//类似前插操作，有两种实现方式
//1.0传入头指针，遍历结点，查到目标结点的前驱结点，再将目标节点删除
    bool ListDelete(LinkList &L,LNode *p)

//2.0建立一个新结点指向目标结点的后继，把该结点的内容写入p，再删除该后继结点（间接删除p）（该做法的前提是p结点不是最后一个结点，即p结点有后继）
    bool ListDelete(LNode *p)
    {
        LinkList *q;//由于q将要指向的是已经存在的结点，而不是创建一个新结点，故不需要申请分配内存
        q=p->next;      //q为p的后一个结点
        p->data=q->data;//q的数据传给p结点（思考：p结点的数据是否要写回？）
        p->next=q->next;//p的中存储下一个结点的指针修改为q中指向下一个结点的指针
        //q-data也可写为p->next->data;q->next也可写为p->next->next；
        free(q);
        return true;
    }
```
> 查找（带头结点的单链表）

* 按位查找（带头结点的单链表）
```c
LNode *GetElem(LinkList L,int i)    //注意该函数返回类型为指向结构的指针，不需要对实参修改故不用引用类型
{
    if(i<0)                 //判断i是否合理
        return NULL;        //布尔类型返回true或false，此处返回的为指针，当出现错误则应返回空指针NULL
    
    //算法主体
    LNode *p=L;
    int j=0;                //表示目前p指向结点j
    while(p!=NULL && j<i)//当j=i时，p已指向结点i，不应再进入循环（j<i等价于j<=i-1）
    {
        p=p->next;
        j++;
    }

    return p;               //注意返回值为p（指向结构的指针）

}
```
* 按值查找（带头结点的单链表）
```c
LNode *LocateElem(LinkList L,ElemType e)
{
    LNode *p=L-next;                //从第一个存储数据的结点开始（也可以从头结点开始？）
    while(p!=NUll && p->data!=e)    //判断p部位空指针是为了判断是否到达最后一个结点的下一个结点（NULL）
    {
        p=p->next;
    }

    return p;                       //找到后返回指向该结点的指针，否则返回NULL
}
```
> 求长度(带头结点的单链表）

```c
int lenth(LinkList L)
{
     int i=0;
     LNode *p=L;
     while(p->next!=NULL)
     {
        p=p->next;
        i++;
     }
     return i;

}
```
> 单链表的建立(带头结点的单链表)

* 尾插法
```c
LinkList List-TailInsert(LinkList &L)
{
    L=(LNode *)malloc(sizeof(LNode));
    L->next=NULL;   //初始化为空链表
    int e;          //e其实是ElemType，此处为了方便读取故选int
    LNode *p,*q;    //用p来接受新结点，q指向尾结点
    scanf("%d",&e); //其实可以来自任意一种输入类型
    q=L;
    while(e!=99999) //该条件可该为任意需要终止输入的条件
    {
        p=(LNode *)malloc(sizeof(LNode));
        p->data=e;  //p为新插入的结点
        q->next=p;  //将q连在p后
        q=p;        //q变为尾结点
        scanf("%d",&e);
    }
    q->next=NULL;   //尾结点指针置空
    return L;
}
```

* 头插法
  * Tips：头插法可实现**链表逆置**
```c
LinkList List_HeadInsert(LinkList &L)
{
    L=(LNode *)malloc(sizeof(LNode));
    L->next=NULL;                           //L后继置空
    LNode *P;                               //建立新结点
    int e;                                  //存放新数据
    scanf("%d",e);
    whlie(e!=9999)
    {
        p=(LNode *)malloc(sizeof(LNode));   //为新结点分配内存
        p->data=e;                          //存入新数据
        p->next=L->next;                    //将L的后继结点连在p后面
        L->next=p;                          //将p连在L后面
        scanf("%d",e);
    }

    return L;
}
```
#### 封装思想
> 利用封装思想实现在第i个位置后面的插入操作

```c
bool ListInsert(LinkList &L,int i,ElemType e){
    if(i<1)
        return false;
    Lnode *p=GetElem(L,i-1);    //找到结点i-1
    return InsertNextNode(p,e); //在p后面插入新数据e
}
```
#### 双链表定义
```c
typedef struct{
    ElemType data;
    DNode *piror,*next;
}DNode,*DLinkList;   //DLinkList x等价于DNode *x
```
#### 双链表基本操作
> 初始化（带头结点的双链表）

```c
bool InitDLinkList(DLinkList &L)
{
    L=(DNode *)malloc(sizeof(DNode));   //为头结点分配内存空间
    if(L==NULL)                         //内存分配失败的处理
        return false;
    L->prior=NULL;                      //头结点的prior永远指向NULL
    L->next=NULL;                       //下一个结点还不存在

    return true;
}
```
> 判空（带头结点的双链表）

```c
bool IsEmpty(DLinkList L)
{
    if(L->next==NULL)
        return ture;
    else
        return false;
}
```

> 插入（带头结点的双链表）

* 后插操作
```c
bool InsertNextDNode(DNode *p,DNode *q) //采用已知结点方式，注意考虑参数非法、p为最后一个结点的问题
{
    if(p==NULL || q==NULL)      //处理非法参数
        reutrn false;
    q->next=p->next;            //将p的后继结点接到q后面
    if(p->next!=NULL)           //判断p是否为最后一个结点，若是则不应修改p后继结点的前指针
        p->next->prior=q;       //让p后继结点的前指针指向q
    q->prior=p;                 //q的前指针指向p
    p->next=q;                  //p的后指针指向q

    return true;
}
```
* 前插操作
```c
bool InsertPriorDNode(DNode *p,DNode *q)
{
    if(p==NULL || q==NULL)
        return false;
    q->next=p;          //q的后指针指向p
    q->prior=p->prior;  //q的前指针指向p的前一个结点
    p->prior->next=q;   //p的前一个结点的后指针指向q
    p->prior=q;         //p的前指针指向q
}
```

> 结点删除

```c
//删除指定结点p
bool DeleteNextDNode(DNode *p)      //注意考虑参数非法、p为最后一个结点的问题
{
    if(p==NULL)                     //判断p是否合法
        return false;
    if(p->next!=NULL)               //p有无后继结点
        p->next->prior=p->prior;    //p后继结点的前指针指向p的前驱结点
    p->prior->next=p->next;         //p前驱结点的后指针指向p的后继结点
    free(p);
    return true;
}

//删除p的后继结点q
bool DeleteextDNode(DNode *p)
{
    if(p==NULL) return false;
    DNode *q=p->next;           //找到p的后继结点q
    if(q==NULL) return false;   //q不存在的处理
    p->next=q->next;            //p的后指针指向q的后继结点
    if(q->next!=NULL)           //q不是最后一个结点
        q->next->prior=p;       //q的后继结点的前指针指向p
    free(q);

    return true;
}
```
### 循环单链表
* 表尾指针指向头结点
### 循环双链表
* 表尾的尾指针指向头结点，头结点的前指针指向表尾
### 静态链表
```c
#define MaxSize 10  //静态链表的最大长度
typedef struct{
    ElemType data;
    int next;       //指向下一个结点的数组下标
}SLinkList[MaxSize] /*相当于用struct定义了一个结构，
                    再用typedef关键字将该结构类型命名为一个SLinkList的数组类型，
                    之后便可用该名字去声明一个变量（该变量即为该存储该种结构的数组）*/
```


### 代码健壮性问题
* 非法参数
* 判断结点是否为表尾表头结点
* 表头、表尾结点是否需要特殊处理

## 栈(stack)
* 栈是**只允许在一端进行插入或删除操作**的*线性表*

几个概念：
* 栈顶
* 栈底
* 空栈

特点：
* 后进先出(Last In First Out,LIFO)

常考题型——合法出栈顺序
基本操作：

### 顺序栈
* 顺序栈基本实现

```c
#define MaxSize 10
typedef struct{
    ElemType data[MaxSize]; //静态数组存放栈中元素
    int top;                //栈顶指针(此处为数组下标)
}SqStack;//sequence n.顺序

void testStack9(){
    SqStack S;              //声明顺序栈S
    ......
}
```

* 基本操作
  * 注意栈顶指针的两种实现方式：
    1. 栈顶指针指向**当前栈顶元素**
    2. 栈顶指针指向**下一个可以插入的位置**


> 初始化与判空(栈顶指针指向栈顶元素)


```c
//初始化
SqStack S;
void InitStack(SqStack &S)
{
    S.top=-1;       //初始化栈顶指针
}

//判空
bool StackEmpty(SqStack &S)
{
    if(S.top==-1)
        return true;
    else
        return false;
}
```
> 进栈与出栈

```c
//进栈
bool Push(SqStack &S,ElemType x)
{
    if(S.top==MaxSize-1)
        return false;
    S.data[++S.top]=x;  //等价于:S.top++; S.data[S.top]=x; 
    //注意++的位置，应先让S.top加1，再赋值
    return true;
}

//出栈
bool Pop(SqStack &S,ElemType &x)    //注意数据x涉及输出，故需要引用
{
    if(S.top==-1)
        return false;
    x=S.data[S.top--];      //等价于:x=S.data[S.top]; S.top--;
    //注意--位置，应先赋值，再S.top-1
    return true;
}
```

> 读取栈顶元素

```c
bool GetTop(SqStack S,ElemType &x)
{
    if(S.top==-1)
        return false;
    x=S.data[S.top];
    return true;
}
```

* 共享栈

```c
#define MaxSize 10
typedef struct{
    Elemtype data[MaxSize];
    int top0;
    int top1;
}ShStack;

//初始化栈
void InitStack(ShStack &s){
    S.top0=-1;
    S.top1=MaxSize;
}

//判断栈满的条件：top0+1==top1
```

### 链栈
* 注意有两种实现方式
  * 带头结点
  * 不带头结点(推荐)
```c
//实现方式:选择在表头增减，因为逆向寻找前结点不能实现或时间复杂度高
typedef struct LinkNode{
    Elemtype data;
    struct LinkNode *next;  //栈顶指针
}*LiStack;


//初始化(不带头结点)
bool InitListack(LiStack *S)
{
    S=NULL;
    return true;
}

//进栈(不带头结点)
bool Push(LiStack S,ElemType x)
{
    LinkNode *p=(LinkNode *)malloc(sizeof(LinkNode));
    if(p==NULL)
        return false;
    //S指向空时不需要特殊处理
    p->data=x;       //将数据传入新结点
    p->next=S;       //将表头链接到新结点后面
    S=p;             //让表头指向新结点
    return true;
}

//出栈(不带头结点)
bool Pop(LiStack S,ElemType &x)
{
    if(S==NULL)
        return false;
    LiStack *p;         
    x=S->data;          //传出数据
    p=S;                //存放栈顶指针
    S=S->next;          //栈顶指针向下减1
    free(p);
}

//查找(获取栈顶元素)(不带头结点)
bool GetTop(LiStack S,ElemType &x)
{
    if(S==NULL)
        return false;
    x=S->data;
}

//判空(不带头结点)
bool StackEmpty(LiStack S)
{
    if(S==NULL)
        return true;
    eles
        return false;
}

//初始化(带头结点)
bool InitStack(LiStack S)
{
    LiStack *L=(LiStack *)malloc(sizeof(LiStack));
    if(L==NULL)
        return false;
    L->next=NULL;
    return true;
}

//进栈(带头结点)
bool Push(LiStack *S,ElemType x)
{
    LiStack *p=(LiStack *)malloc(sizeof(LiStack));
    if(p==NULL)
        return false;
    p->data=x;
    p->next=S->next;
    L->next=p;
    //以上代码可用单链表(带头结点)后插函数实现：ListInsert(LinkList &L,int i,ElemType e);
    return true;
}

//出栈(带头结点)
bool Pop(LiStack *S,ElemType &x)
{
    if(S->next==NULL)
        return false;
    LiStack *p=S->next; //获取栈顶指针
    x=p->data;          //输出栈顶元素
    S->next=p->next;    //将栈顶元素后继连到头结点后
    free(p);            //释放栈顶元素空间
    //以上代码可用单链表(带头结点)删除函数实现：ListDelete(LinkList &L,int i,ElemType &e)
    return true;
}

//查找(获取栈顶元素)(带头结点)
bool GetTop(LiStack *S,ElemType &x)
{
    if(S->next==NULL)
        return false;
    LiStack *p=S->next; //获取栈顶指针
    x=p->data;          //获取栈顶元素
    //以上代码可用单链表(带头结点)按位查找函数实现：x=GetElem(LinkList L,int i)
    return true;
}
```

## 队列(Queue)
### 队列
* 只允许在**一端进行插入，在另一端删除**的*线性表*
  * 入队
  * 出队

术语：
* 队头
* 队尾
* 空队列

特点：
* 先进先出(First In First Out,FIFO)

基本操作概述：
* InitQueue(&Q)
* DestoryQueue(&Q)
* EnQueue(&Q,x)
* DeQueue(&Q,&x)
* GetHead(Q,&x)
* QueueEmpty(Q)

队列的实现：
1. 顺序实现

```c
//顺序实现方式
#define MaxSize 10
typedef struct{
    ElemType data[MaxSize];
    int front,rear; //队头指针、队尾指针(实际为数组下标)
                    //此处规定：队头指针指向队头元素，队尾指针指向队尾元素的后一个位置(待插入位置)

    //rear   v.抚养；养育；饲养；培养
    //       n.屁股；后部；臀部
    //       adj.后面的；后部的
}SqQueue;


//初始化
void InitQueue(SqQueue &Q)
{
    Q.rear=Q.front=0;   //注意此操作根据队尾、队头指针指向的位置而定
}


//判空
bool QueueEmpty(SqQueue Q)
{
    if(Q.rear==Q.front)
        return true;
    else
        return false;
}


//入队
bool EnQueue(SqQueue &Q,ElemType x)
{
    //判断队列是否已满
    if((Q.rear+1)%MaxSize == Q.front)       //不采用rear与front相等，因为判空操作条件为两者相等
                                            //此时浪费一个存储空间来满足该条件成立
        return false;
    Q.data[Q.rear]=x;
    Q.rear=(Q.rear+1)%Maxsize;  //由于队尾指针应能循环使用已经出队的元素的位置，故可采用取模操作循环回去
                                //注意应对Q.rear+1取模，而非Q.rear取模再+1
                                //注意此时判满操作比较特殊
    return true;
}


//出队
bool DeQueue(SqQueue &Q,ElemType &x)
{
    if(Q.rear == Q.front)       //此处为判空，而非判满
        return false;
    x=Q.data[Q.frone];
    Q.front=(Q.fronr+1)%MaxSize;
    return true;
}

//查询(队头)
bool GetHead(SqQueue Q,ElemType &x)
{
    if(Q.rear==Q.front)
        return false;
    x=Q.data[Q.front];
    return true;
}


//Tips：
    //1.队列元素个数：(rear+MaxSize-front)%MaxSize
    //2.可以新增加一个变量size来统计队列当前还有多少元素来判空、判满(此方法就不用浪费一个存储空间)
    //3.可以新增标志位tag来判空、判满，插入操作将tag置1，删除操作将tag置0，
    //  只有当front==rear && tag==1，表示两指针重叠是由上次的插入操作导致的，说明队列满
    //  只有当front==rear && tag==0，表示两个指针重叠是由删除操作导致，说明队列空
    //4.注意队头、队尾指针初始化的位置

```
2. 链式实现方式

```c
//实现思想：单链表基础上设队头、队尾指针
typedef struct LinkNode{
    ElemType data;
    struct LinkNode *next;
}LinkNode;
typedef struct{
    LinkNode *front,*rear;
}LinkQueue;     //此处只是定义了一个结构类型并重命名，
                //用此类型命名的变量为结构变量，而非指向结构的指针


//初始化（带头结点）
void InitQueue(LinkQueue &Q)
{
    Q.front=Q.rear=(LinkQueue *)malloc(sizeof(LinkQueue));
    Q.front->next=NULL;       //没有下一个结点
}

//判空(带头结点)
bool QueueEmpty(LinkQueue Q)
{
    if(Q.front==Q.rear)
        return true;
    eles
        return false;
}

//初始化(不带头结点)
void InitQueue(LinkQueue &Q)
{
    Q.front=NULL;
    Q.rear=NULL;
}

//判空(不带头结点)
bool QueueEmpty(LinkQueue Q)
{
    if(Q.front==NULL)
        return true;
    else
        return false;
}

//入队(带头结点)
bool EnQueue(LinkQueue &Q,ElemType x)
{
    //表尾为空不需要特殊处理
    LinkNode *p=(LinkNode *)malloc(sizeof(LinkNode));   //注意是申请新结点的空间，而非新的队列类型的空间
    p->data=x;
    p->next=NULL;
    Q.rear->next=p;     //将p连于队尾后
    Q.rear=p;           //将队尾指向p
}


//入队(不带头结点)
bool EnQueue(LinkQueue &Q,ElemType x)
{
    LinkNode *p=(LinkNode *)malloc(sizeof(LinkNode));
    p->data=x;
    p->next=NULL;
    //队头队尾为空需要特殊处理
    if(Q.front==NULL)
        Q.front=p;      //队头为空时，队头队尾均需指向新结点
        Q.rear=p;
    else
        Q.rear->next=p; //队列非空时，将p连到队尾后
        Q.rear=p;       //修改队尾指针
}


//出队(带头结点)
bool DeQueue(LinkQueue &Q,ElemType &x)
{
    if(Q.front==Q.rear)     //处理空队列
        return false;
    LinkNode *p=Q.front;
    x=p->data;
    //队头指针的next为空(最后一个元素出队)，队头不需要特殊处理
    Q.front=Q.front->next;  //队头指针指向下一个元素
    //出队的是最后一个元素，队尾指针需要特殊处理
    if(p==Q.rear)
        Q.rear=Q.front;     //修改队尾指针
    free(p);

    return true;
}


//出队(不带头结点)
bool DeQueue(LinkQueue &Q,ElemType &x)
{
    if(Q.front==NULL)
        return false;
    LinkNode *p=Q.front;
    x=p.data;
    //队头元素下一个元素为空(最后一个元素出队)，队头不需要特殊处理
    Q.front=Q.front->next;
    //出队元素是最后一个结点，应将尾指针置空
    if(p==Q.rear)
    {
        Q.front=NULL;
        Q.rear=NULL;
    }
    free(p);
    
    return true;
}

//链式存储不用担心队列满的情况
```

### 双端队列
* 栈：只允许从**一端插入和删除**的线性表
* 队列：只允许从**一端插入、另一端删除**的线性表
* 双端队列：只允许从**两端插入、两端删除**的线性表 
  * 输入受限的双端队列：只允许从**一端插入、两端删除**的线性表
  * 输出受限的双端队列：只允许从**两端插入、一端删除**的线性表

* 重要考点：判断输出序列的合法性

### 栈的应用——括号匹配问题
分析：
* 最后出现的左括号最先被匹配(LIFO)——可用"栈"实现该特性
* 每出现一个右括号，应该"消耗(匹配)"一个左括号
* 特殊情况处理：
  1. 扫描到右括号，而栈空，表示未匹配
  2. 已经处理完所有输入的括号，但栈非空，即仍留有(左)括号，表示未匹配
  3. 左右括号不匹配(如左小括号—右中括号)

代码实现：(尽量避免使用基本操作)
```c


```

### 栈的应用——表达式求值
> 三种表达式
* 中缀表达式:运算符在两个操作数**中间**
* 前缀表达式(波兰表达式):运算符在两个操作数**后面**
* 后缀表达式(逆波兰表达式):运算符在两个操作数**前面**

> 中缀转后缀(手算)

  1. 确定中缀表达式中各个运算符的运算顺序
  2. 选择下一个运算符，按[左操作数 右操作数 运算符]的方式组合成一个新的操作数
  3. 如果还有运算符没有被处理，则继续第2步

> 中缀转后缀(机算)

  1. 从左到右处理各个元素，直到末尾
  2. 遇到**操作数**：直接加入后缀表达式
  3. 遇到**界限符**：遇到"("直接入栈；遇到")"则依次弹出栈内运算符并加入后缀表达式，知道弹出"("为止。注意："("不加入后缀表达式
  4. 遇到**运算符**：依次弹出栈汇总优先级高于或等于当前运算符的所有运算符，并加入后缀表达式，若碰到"("或栈空则停止。之后在把当前运算符入栈

```c 
//伪代码实现(注意栈应分配合理大小，否则将导致溢出)

```

> 后缀表达式手算：
> 
从左往右扫描，每遇到一个运算符，就让运算符前面最近的两个操作数执行对应运算，并合为一个操作数

> 用栈实现后缀表达式计算(机算)：

  1. **从左往右**扫描下一个元素，直到处理完所有元素
  2. 若扫描到**操作数**，则压入栈，并回到1；否则执行3
  3. 若扫描到**运算符**，则弹出两个栈顶元素，执行相应运算，运算结果压回栈顶，回到1(先弹的为右操作数，后弹的为左操作数)

> 中缀表达式的计算(机算)——结合中缀转后缀以及后缀表达式计算

  1. 初始化两个栈，操作数栈和运算符栈
  2. 若扫描到操作数，压入操作数栈
  3. 若扫描到运算符或界限符，则按照中缀转后缀的步骤压入运算符栈(弹出的运算符，可直接对应操作数栈，并按照后缀表达式计算步骤处理)

> 中缀转前缀

Tips：
* 由于运算顺序可以不唯一，因此对应的
   1. 后缀表达式也不唯一。对于计算机而言，"只要左边的运算符能先计算，就先算左边的(左优先)"
   2. 前缀表达式也不唯一。对于计算机而言，"只要右边的运算符能先计算，就先算右边的(右优先)"

### 栈的应用——递归
* 函数调用的特点——最后被调用的函数最先执行结束(LIFO,Last In First Out)
* 递归模型条件
  * 递归表达式(递归体)
  * 边界条件(递归出口)

### 队列的应用——树的层次遍 历、图的广优先遍历

### 数组和特殊矩阵
> 特殊矩阵的压缩存储
* 对称矩阵
* 三角矩阵
  * 上三角矩阵
  * 下三角矩阵
* 三对角矩阵(带状矩阵)
> 稀疏矩阵

## 串
### 概述
> 串：即**字符串(String)**，由0个或多个字符组成的有限序列，一般记为S='a1a2a3......an'


* S是**串名**，单引号中的字符序列为串的值
* 串中字符的个数n为**串的长度**，n=0时的串称**空串**(用∅表示)
  * 特别注意：M=''与N=' '不一样，前者为空串(长度为0)，后者为空格串(内含一个空格，长度为1)
* **子串**
* **主串**
* 字符在主串中的位置(从1开始数)
* 子串在主串中的位置：子串第一个字符在主串中的位置

> 串是特殊的线性表，数据元素之间呈线性关系，数据对象限定为**字符集**，基本操作通常以**子串**为操作对象

* StrAssign(&T,chars);
* StrCopy(&T,S);
* StrEmpty(S);
* StrLength(S)
* ClearString(&S);
* DestorySting(&S);
* Concat(&T,S1,S2);
* SubSting(&Sub,S,pos,len);
* Index(S,T);
* StrCompare(S,T);

> ASCII字符集

### 存储方式
> 顺序存储
* 四种存储方案
 1. 数组最后一个元素记录长度
 2. 数组第一个元素记录长度(注意由于数组类型为char型，最大值只能为255)
 3. 以\0结尾(该方案得到长度困难)
 4. 空出数组第一个元素，在最后一个元素处记录长度(保持数组下标与字符位置一致)


```c
//定长数组存储
#define MAXLEN 255
Typedef struct{
    char data[MAXLEN];  //每个分量存储一个字符
    int length;              //串实际的长度
}SString;


//堆分配存储
typedef struct {
    char *ch;       //指向由malloc动态分配的空间
    int length;     //串长
}HString;
HString S;
S.ch=(char *)malloc(MAXLEN * sizeof(char)); //注意最后需要手动free
S.lenth=0;  //初始化长度

```

> 链式存储

```c
//不推荐打方案(因为存储密度低)
typedef struct StringNode{
    char ch;                    //字符占1B
    struct StringNode *next;    //指针占4B
}StringNode,* String;


//建议每个结点多存几个字符(提高存储密度)
typedef struct StringNode{
    char ch[4];
    struct StringNode *next;
}StringNode,*String;
```
### 基本操作(了解)
```c
SString S;
//注意采用首元素空的方案(数组下标和字符位置下标一致)


//求子串
bool SubString(SString &Sub,SString S,int pos,int len)
{
    if(pos+len-1 >S.length)     //(起始位置+子串长度-1)最后一个元素的序号大于主串长度应报错
        return false;
    for(int i=1;i<=len;i++)
    {
        Sub.ch[i]=S.data[pos+i-1];  //此处Sub也采用首位空一个元素
    }
    /*另一种循环体
    for (int i=pos;i<pos+len;i++)
    {
        Sub.ch[i-pos+1]=S.ch[i];
    }
    */

    sub.length=len;             //别忘了修改长度

    return true;
}


//比较
int StrCompare(SString S,SString T)
{
    for(int i=1; i<=S.length && i<=T.length ;i++)
    {
        if(S.ch[i]!=T.ch[i])
            return S.ch[i]-T.ch[i];
    }

    //扫描过的所有字符都相同，则长度长的串更大
    return S.length-T.length;
}


//定位
int Index(SString S,SString T)
{
    SString Sub;        //暂存遍历的子串
    int n=StrLength(S),m=StrLength(T);
    for(int i=1;i+m-1<=n;) //匹配串中最后一个元素的序号(T.length+i-1)大于主串长度应报错
    //(也可以这样理解:主串中共有n-m+1个m长度的子串)
    {
        SubString(&Sub,S,i,m);   //每次取出T长度的子串
        if(Strcompare(Sub,T)!=0) i++;   //i++也可写入循环迭代条件
        else return i;          //匹配成功则返回子串位置
    }
    return 0;   //执行到此语句说明S未找到匹配的T子串，返回0
}
```

### 串的模式匹配
子串——主串的一部分，**一定存在**
模式串——**不一定**能在主串中找到

> 简单模式匹配算法(朴素模式匹配算法)
最坏时间复杂度O(mn)
```c
//方案1.0   使用基本操作
int Index(SString S,SString T)
{
    SString Sub;        //暂存遍历的子串
    int n=StrLength(S),m=StrLength(T);
    for(int i=1;i+m-1<=n;) //匹配串中最后一个元素的序号(T.length+i-1)大于主串长度应报错
    //(也可以这样理解:主串中共有n-m+1个m长度的子串)
    {
        SubString(&Sub,S,i,m);   //每次取出T长度的子串
        if(Strcompare(Sub,T)!=0) i++;   //i++也可写入循环迭代条件
        else return i;          //匹配成功则返回子串位置
    }
    return 0;   //执行到此语句说明S未找到匹配的T子串，返回0
}


//方案2.0   利用数组下标
//设计两个指针，i指向主串与j指向模式串中要对比的元素，每对比成功，指针都+1
//匹配失败时：i=i=j+2(表示从主串上一次匹配失败后的第二个元素开始),j=1(模式串又从第一个开始比较)
//完全匹配：将导致j>模式串长度，i应返回匹配成功的子串首元素序号，i=i-j
int Index(SString S,SString T)
{
    int i=1,j=1;
    while(i<=S.length && j<=T.length)   //i超过长度表示没有模式串而需要退出，
                                        //j超过长度表示匹配到模式串，此时应退出
    {
        if(S.ch[i]==T.ch[j])
        {
            i++;    //继续比较后续字符
            j++;
        }
        else
        {
            i=i-j+2;    //指针后退，重新开始匹配
            j=1;
        }
    }
    if(j>T.length)      //判断是否全部匹配完成
        return i-T.length;
    else
        return 0;
}


//方案XXX  自己写的垃圾代码
int Index(SString S,SString T)
{
    int i=1,j=1;
    int n=StrLength(S),m=StrLength(T);
    for(int a=1;a<=m-n+1;a++)   //判断结束出问题了
    {
        if(j<=m)
        {
            if(S.ch[i]==T.ch[j])
            {
                i++;
                j++;
            }
            else{
                i=i-j+2;
                j=1;
            }
        }
        else return i-j;    //此处不应用j，因为j已经超出T.Length
    }
}
```

> KMP算法(基于朴素模式匹配算法的优化)
> (不用掌握代码实现，但需要手动模拟)
* 步骤：
  1. 根据模式串T，求出其next数组
  2. 利用next数组进行匹配(主串指针不回溯)

* 时间复杂度：最坏时间复杂度O(m+n)


```c
int Index_KMP(SString S,SString T,int next[])
{
    int i=1,j=1;
    while(i<=S.length && j<=T.length)
    {
        if(j==0 || S.[i]==T.[j])    //新增j为0的情况(与模式串第一个元素就匹配失败时)
                                    //此时应让i++;j++
        {
            i++;
            j++;
        }
        else
        {
            j=next[j];              //模式串的指针回溯，主串指针不变
                                    //此处使用的next数组下标也是第一个元素置空，保持数组下标与字符序号一致
        }

        if(j>T.length)
            return i-T.length;      //匹配成功的返回值
        else
            return 0;               //匹配失败返回0
    }
}

```

* next数组手算
  * next[1]一定为0
  * next[2]一定为1
  * 其他next：在不匹配的位置前划一条分界线，模式串一步一步往后退，知道分界线前的部分能与主串分界线前的部分"能对上"，或者模式串完全跨过分界线为止，此时next数组的值即为j指向元素的序号(即分界线后模式串中第一个元素的序号)

> KMP算法进一步优化

* nextval数组手算
  * next[1]一定为0
  * 其他next：
    * 如果当前next\[j]所指向的字符与目前j所指的字符不相等，next[j]不变
    * 如果当前next\[j]所指向的字符与目前j所指的字符相等，next[j]=next\[next\[j]]，即让j的next值为其原来的next所指向元素的next值

```c
nextval[1]=0;
for(int j=2;j<=T.length;j++){
    if(T.ch[next[j]]==T.ch[j])
        nextval[j]=nextval[next[j]];
    else
        nextval[j]=next[j];
}
```

## 树
### 二叉树
#### 二叉树的存储
```c
//顺序存储
#define MaxSize 100     //最大长度
typedef TreeNode{       //定义结点结构
    Elemtype value;     //数据域
    bool isEmpty;       //结点是否为空
}TreeNode;

TreeNode t[MaxSize];    //用数组来储存结构
//可以让数组下标为0的元素置空，以保持数组下标和结点序号一致

for(int i=0;i<MaxSize;i++)  
    t.isEmpty=true;     //初始化二叉树操作：将所有结点置空
//为方便实现对子节点的随机存储，
//通常将二叉树与完全二叉树的结点编号对应起来，结果可能造成浪费大量空间
//访问结点问题(完全二叉树)：对于父节点i：左孩子2i，右孩子2i+1


//链式存储(二叉链表)
struct ElemType{
    int value;          //该举例中，ElemType每个仅包含int类型变量
};

typedef struct BiNode{
    ElemType data;
    struct BiNode *lchild,*rchild;  //左、右孩子指针
    //(如有必要，可定义一个父节点指针，方便找父节点，形成三叉链表)
}BiNode,*BiTree;       //用BiNode表示声明的为分支结点
                        //用BiTree表示声明的为根节点(即一个二叉树)

```

#### 二叉树基本操作(基于二叉链表)
```c
BiTree root=NULL;

//创建根节点
root=(BiNode *)malloc(sizeof(BiNode));
root.data={1};
root.lchild=NULL;
root.rchild=NULL;

//插入新结点
BiNode *p=(BiNOde *)malloc(sizeof(BiNode));
p.data={2};
p.lchild=NULL;
p.rchile=NULL;
root.lchild=p;      //p作为根节点的左孩子
```

#### 二叉树先中后序遍历(基于链式存储)
> 算法思想：
* 递归
* 注意顺序

> 该递归思想可推广至很多算法思路

```c
void PreOrder(BiTree T){
    if(T!=NULL){            //注意：执行该递归的条件
        visit(T);           //先访问根节点
        PreOrder(T->lchild);//利用递归，访问左子树
        PreOrder(T->rchild);//利用递归，访问右子树
    }
}


void InOrder(BiTree T){
    if(T!=NULL){
        InOrder(T->lchild);
        visit(T);
        Inorder(T->rchild);
    }
}

void PostOrder(BiTree T){
    if(T!=NULL){
        PostOrder(T->lchild);
        PostOrder(T->rchild);
        visit(T);
    }
}

```

#### 二叉树的层序遍历
> 算法思想

1. 初始化一个辅助队列
2. 根节点入队
3. 若队列非空，则队头结点出队，访问该结点，并将其左右孩子插入队尾(如果有左右孩子的话)
4. 重复第三步直至队列空

```c
void d(BiTree T){
    LinkQueue Q;
    InitQueue(Q)                    //注意：初始化辅助队列
    Bitree p;                       //用p来接取出队的结点
    InQueue(Q,T);                   //根节点入队
    while(IsEmpty(Q)){              //注意：判空条件使用函数实现
        Dequeue(Q,p);               //队头结点出队
        visit(p);                   //访问出队结点
        if(p->lchild != NULL)       //注意：判断左右孩子是否存在
            InQueue(Q,T->lchild);
        if(p->rchild != NULL)
            InQueue(Q,T->rchild);
    }
}
```

### 线索二叉树
#### 定义
```c
typedef struct TreadNode{
    ElemType data;              //数据域
    TreadNode *lchild,*rchild;  //左右孩子指针
    int ltag,rtag;              //左右线索标志(1表示该孩子指针指向的是线索，0表示孩子指针指向的为孩子)
}TreadNode,*TreadTree;
```

#### 线索化
> 对于中序序列，寻找特定结点p的前驱
```c
//自己写的代码
bool link(BiTree T,BiNode p){
    BiNode pre=NULL;//前驱结点
    BiNode q;//当前扫描结点，这个其实没有用到
    void visit(BiNode ptr){
        if(ptr!=p)
            pre=ptr;        //想法大体对的，但是没考虑到这个函数会不停在嵌套中使用，导致最终pre的值不是正确结果
    }
    InOrder(T);
}

//来看看正确的
//全局变量
BiTNode *p          //p指向目标结点
BiTNode *pre=NULL;  //指向当前访问结点的前驱
BiTNode *final=NULL;//记录最终结果

void visit(BiTNode *q){
    if(q==p)        //当前结点正好是p时，记录最终前驱
        final=pre;
    else
        pre=q;      //否则，让pre指向当前结点，等待下一级嵌套
}
```

> 中序线索二叉树的构造(基于链式存储)

```c
TreadTree pre=NULL;                         //全局变量pre
void visit(ThreadNode *p){
    if(p->lchild == NULL){                  //构造当前结点的前驱
        p->lchild=pre;
        p->ltag=1;                          //别忘了修改标志位
    }
    if(pre != NULL && pre->rchild == NULL){ //注意：构造的是前驱结点(上一个结点)的后继，
//                                                  因为当前结点的后继还没遍历到
        pre->rchild=p
        pre->rtag=1
    }
    pre=p;                                  //当前结点将作为下一个访问结点的前驱
}

void InThread(TreadTree T){
    if(p!=NULL){
        InThread(T->lchild);
        visit(p);
        InThread(T->rchild);
    }
}

//中序线索化二叉树主函数
void CreatInThread(TreadTree T){
    if(T!=NULL){                        //非空树才进行线索化
        InThread(T);                    //1.线索化
        if(pre->rchild == NULL)         //注意：2.处理最后一个结点的标志位
        pre->rtag=1;
    }

}
```
> 先序线索二叉树构造

* Tips：有一个死循环需要额外处理
```c
ThreadNode *pre=NULL;

void visit(ThreafNode *p){
    if(p->lchild==NULL){
        p->lchild=pre;
        p->ltag=1;
    }
    if(pre!=NULL && pre->rchild==NULL){
        pre->rchild=p;
        pre->rtag=1;
    }
    pre=p;
}

void PreThread(TreadTree T){
    if(T!=NULL){            //嵌套结束的条件是——该结点为空结点(表示该层嵌套处理的是叶子结点的分支——空节点)
        visit(T);
        //当到达最后一个结点时，由于结点已经被线索化，
        //故左孩子指向pre(上一个处理的结点，即当前结点的根节点)，再使用嵌套，将导致陷入死循环
        if(T->ltag==0)
            PreThread(T->lchild);
        //为什么只处理左孩子那边的嵌套？
        //因为右孩子线索在处理下一个结点时才会被建立，故右叶子结点仍为空
        PreThread(T->rchild);
    }
}

void CreatPreThread(ThreadTree &T){
    if(T!=NULL){
        PreThread(T);
        if(pre->rchild==NULL)
            pre->rtag=1;
    }
}
```

> 后序线索二叉树构造
```c

```

> 线索二叉树的遍历、寻找某结点的前驱后继

* 中序线索二叉树
```c
//1.寻找中序线索二叉树中某结点p的中序前驱
    //经分析，左孩子存在时，前驱为左子树最右下方的结点

//寻找最右下方的结点
ThreadNode *LastNode(ThreadNode *p){
    while(p->rtag==0)
        p=p->rchild;
    return p;
}

//寻找前驱结点
ThreadNode *PreNode(ThreadNode *p){
    if(p->ltag=1)
        return p->lchild;
    else
        return LastNode(p->lchild);//寻找左子树中，最右下方的结点(即p的前驱)
}


//2.寻找中序线索二叉树中某结点p的中序后继
    //经分析，右孩子存在时，后继为右子树最左下方的结点(不一定为叶节点)

//寻找最左下方的结点(不一定是叶节点)
ThreadNode *FirstNode(ThreadNode *p){
    while(p->ltag==0)
        p=p->lchild;
    return p;
}

//寻找p的后继后继结点
ThreadNode *NextNode(ThreadNode *p){
    if(p->rtag==1)
        reutrn p->rchild;
    else
        return Firstnode(p->rchild);//右孩子不是线索时，应寻找右子树中最左下的结点(即p的后继)
}


//3.遍历中序线索二叉树
void InOrder(TreadTree T){
    if(T!=NULL){
        ThreadNode *ptr=FirstNode(T);   //由根节点找到中序线索二叉树在中序序列下的第一个结点
//                      (注意该结点为左子树最左下的结点，可能不是根节点的前驱，不能用寻找前驱的算法)
        while(ptr!=NULL){
            visit(ptr);
            ptr=NextNode(ptr);          //不断寻找后继结点
        }
    }
}
//另一种实现方式
void InOrder(TreadTree T){
    for(ThreadNode *p=FirstNode(T);p!=NULL;p=NextNode(p))
        visit(p);
}

//4. 对中序线索二叉树进行逆向遍历
void ReInOrder(ThreadTree T){
    for(ThreadNode *p=LastNode(T);p!=NULL;p=PreNode(p))
        visit(p);
}
```
* 先序线索二叉树的遍历、寻找某结点的前驱后继
```c

```


* 后序线索二叉树的遍历、寻找某结点的前驱后继
```c

```

### 树
> 树的存储结构
* 双亲表示法
* 孩子表示法
* 孩子兄弟表示法
```c
//双亲表示法(顺序存储)
#define MAX_TREE_SIZE 100           //树结点最大限制

typedef struct{                     //结点的定义
    Elemtype data;                  //数据域
    int parent;                     //双亲位置域
}PTNode;

typedef struct{                     //数的定义
    PTNode nodes[MAX_TREE_SIZE];    //用数组存储每个结点
    int n;                          //结点数
}PTree;

//需要思考的问题：
//  1.插入新结点，直接在后方插入即可，不用在意顺序
//  2.删除结点后，可以把删除的位置标志位修改，也可以把最后一个元素移动到空出的位置
//  3.删除非叶子结点，需要对整个树遍历，以找到其各个结点并一一删除，非常麻烦
//  4.查找操作实现困难且耗时(通常需要遍历整个树)


//孩子表示法(顺序+链式存储)
struct CTNode{                  //孩子结点位置关系(接在各节点后面的孩子)
    int child;                  //孩子结点在数组中的位置
    struct CTNode *next;        //指向下一个孩子结点
};
typedef struct{                 //各个结点定义
    ElemType data;              //数据域
    struct CTNode *firstchild;  //指向第一个孩子结点
}CTBox;
typedef struct{                 //树定义
    CTBox nodes[MAX_TREE_SIZE];
    int n,r;                    //结点数，跟结点的位置
}CTree;

//优缺点：查找孩子很方便，但查找双亲困难


//孩子兄弟表示法(最重要)——树与二叉树的转换
typedef struct{
    ElemType data;                      //数据域
    CSNode *firstchild,nextsibling;     //第一个孩子，右兄弟指针
}CSNode,*CSTree;
```

### 哈夫曼树
### 并查集
实现方式：用树来存储集合结构，为方便实现基本操作，推荐使用~~双亲表示法~~
两种基本操作：\[其实还有初始化Initial(s)m]
* Union(S,Root1,Root2)
* Find(S,x)

优化方案：Union操作优化
```c
//并查集结构定义
#define SIZE[100]
int UFSets[SIZE];       //并查集采用树的双亲表示法，而树双亲表示法采用数组作为其结构
//                明确意义：数组下标表示某元素存储的逻辑位置，
//                          数组元素的值代表其父节点所存在的逻辑位置(存储父节点的数组元素下标)，而并非某元素的值

//初始化
void Initial(int *S){
    int i=0;
    while(i<=SIZE){
        UFSets[i]=-1;   //-1表示该结点为根，初始时所有结点都为根
        i++;
    }
}

//查找操作
int Find(int S[],int x){
    while(S[x]>=0){     //通过循环，寻找x的根
        x=S[x];         //每当S[x]的值不是-1，说明x不是根，将x更新为其父节点的位置(数组下标)
    }
    return x;           //返回根
}

//并操作
void Union(int S[],int Root1,int Root2){
    if(Root1==Root2)    return ;//遗忘点：要求Root1和Root2是不同集合，才能采用合并操作
    S[Root2]=Root1;             //Root代表两个根(两个根结点的数组下标)，将根Root2连接到根Root1下(Root2处数组元素存的父节点位置更新为Root1)
}


//并查集优化方案1.0
//  优化Union操作，目的：使合并操作产生的树，深度不再增加
//                方法：1.用根节点的绝对值表示树的结点总数(根节点值为负)
//                      2.Union操作时，让小树合并到大树
void Union(int S[],int Root1,int Root2){
    if(Root1==Root2)    return;

    if(S[Root1]>=S[Root2]){  //Root2绝对值更大时，将Root1连接到Root2下（小树合并到大树）
        S[Root2]+=S[Root1]; //遗忘点：修改结点总数! 注意修改的是数组内的值，而不是修改Root(Root是数组下标)
        S[Root1]=Root2;     //注意：应先修改长度，再将根合并，否则会出错
         
    }  
    else {                   //Root1绝对值更大时，将Root2连接到Root1下
        S[Root1]+=S[Root2];
        S[Root2]=Root1;  

    }   
}


//并查集优化方案2.0
//  优化Find操作(压缩路径)
//      方法：A.经Find操作找到根节点
//          B.将查找路径上的所有结点全部直接挂到根节点
int Find(int S[],int x){
    int root=x;         //根节点(此时还未找到)
    while(S[root]>=0)   //查找根节点
        root=S[root];
    
    while(S[x]!=root){  //注意：判断条件为 是否达到根节点
        int t=s[x];
        S[x]=root;      //将当前结点x直接挂到根节点下
        x=t;
    }
    return root;
}
```

## 图
### 图的存储
```c
//邻接矩阵法(不带权的图)
#define MaxVertexNum 100                    //顶点数目的最大值
typedef struct{
    char Vex[MaxVertex  Num];               //顶点表(存储顶点元素)
    int Edge[MaxVertexNum][MaxVertexNum];   //邻接矩阵(边表)(存储各顶点关系)
    //边表类型可修改为bool(减少存储空间)
    int vexnum,arcnum;                      //当前顶点个数、边数(弧数)
}MGraph;


//邻接矩阵法(带权图)
#define MaxVertexNum 100
#define INFINTY 最大的int值(此处为伪代码，用该值表示无穷大)
typedef char VertexType;
typedef int EdgeType;
typedef struct{
    VertexType Vex[MaxVertexNum];
    EdgeType Edge[MaxVertexNum][MaxVertexNum];
    int vexnum,arcnum;
}MGraph;


//邻接表法(类似树的孩子表示法)
#define MaxVertexNum
typedef struct ArcNode{
    int adjvex;                     //边/弧指向哪个顶点(这是一个数组下标)
    struct ArcNode *next;           //下一条边的指针
    //InfoType info;        
}ArcNode;                           //边/弧结点定义

typedef struct VNode{
    VertexType data;                //数据域
    ArcNode *first;                 //第一条边/弧
}VNode,AdjList[MaxVertexNum];       //顶点结点定义

typedef struct{
    AdjList vertices;               //用数组结构存储顶点
    int vexnum,arcnum;              //当前顶点数目、边数目
}ALGraph;


//十字链表法(需要自己写代码)——用于存储"有向图"


//邻接多重表(需要自己手写代码)——用于存储"无向图"


```
### 基本操作
需要根据其实现所用的存储结构分析

* Adjacent(G,x,y):判断图G是否存在边\<x,y>或(x,y)


### 图的遍历
1. 广度优先遍历——非递归实现
   算法要点：
    1. 找到一个与顶点相邻的所有顶点
    2. 标记哪些顶点被访问过
    3. 需要一个辅助队列

```c
//无向图的广度优先遍历(类似树的层序遍历，又称树的广度优先遍历)

bool visited[MAX_VERTEX_NUM]        //最大长度

void BFStracerse(Graph G){          //健壮性优化

    for(int i=0;i<=G.vexnum;I++){    //初始化标记数组
                                     //注意判断条件为图的大小，而不是最大大小
                                     //此处多初始化了一个元素，是为了使数组下标与图中顶点数目对应
        visited[i]=FALSE;
    }

    InitQueue(Q);                    //初始化辅助队列

    for(int i=1;i<=G.vexnum;i++){       //处理所有非连通子图
                                        //此处从1号开始遍历，是为了使数组下标与图中顶点数目对应
        if(!visited[i])
            BFS(G,i);
    }
}

void BFS(Graph G,int v){
    visit(v);
    visited[v]=TRUE;    //不要忘了修改标记
    EnQueue(Q,v);       //v入队(为了处理其相连结点)
    while(!IsEmpty(Q)){ //队列非空时才处理
        DeQueue(Q);     
        for(w=FirstNeighbor(G,v);w>=0;w=NextNeighbor(G,v,w)){   //w实质为整型，>=0表示有该顶点有邻接点
            if(!visited[w]){        //跳过已经访问过的结点
                visit(w);
                visited[w]=TRUE;
                EnQueue(Q,w);       //不要忘了将刚刚访问的结点入队
            }
        }
    }
}


//有向图的广度优先遍历(视频内有代码，需自己练习)

```

2. 深度优先遍历(参照树的深度优先遍历——先根遍历)——递归实现
   需要对树的深度优先遍历做改进：
   1. 标志位判断
   2. 非连通分量的处理

```c
bool visited[MAX_VERTEX_NUM]        //标记数组

void DFSTraverse(Graph G){          
    for(int v=0;v<G.vexnum;v++){    //初始化标记数组
        visited[v]=FALSE；
    }
    for(int v=0;v<G.vexnum;v++){    //处理未遍历到的非连通分量
        if(!visited[v]){
            DFS(G,v);
        }
    }
}

void DFS(Graph G,int v){            //递归函数，深度遍历
    visit(v);
    visited[v]=TRUE;                //修改标志位

    for(w=FirstNeighbor(G,v);w>=0;w=NextNerghbor(G,v,w)){   //遍历v结点连接的所有结点
        if(!visited[w]){            //只递归访问未访问过的结点w
            DFS(G,w)                //递归
        }
    }
}
```

### 图的应用
* 最小生成树(实现伪代码仅了解)
  1. Prime算法
  2. Kruskal算法
* 最短路径
  * 单源最短路径
    * BFS算法(无权图)
    * Dijkstra算法(带权图、无权图)(实现代码仅了解)
  * 各顶点间的最短路径
    * Floyd算法(带权图、无权图)

```c
//最短路径BFS算法改进——仅适用无权图
void BFS_MIN_Distance(Graph G,int u){
    int d[G.vexnum];    //记录每个顶点路径长度
    int path[G.vexnum]; //记录每个顶点的最短路径从哪个顶点过来(类似树的双亲表示法)

    for(int i=0;i<G.vexnum;i++){
        int d[i]=∞;         //初始化路径长度(无穷为伪代码，意会即可)
        int path[i]=-1;
    }

    d[u]=0;
    visit(u);
    visited[u]=TRUE;
    EnQueue(Q,u);
    while(!IsEmpty(Q)){
        DeQueue(Q,u);           //每次出队的结点为u
        for(w=FirstNeighbor(G,u);w>=0;w=NextNeighbor(G,u,w)){   //注意w起始为u的第一个邻接点，每次循环后更新为下一个邻接点
            d[w]=d[u]+1;        //每次处理u的邻接点时，令其路径长度+1
            visit(w);
            visited[w]=TRUE;
            EnQueue(Q,w);       //不要忘了将刚处理的邻接点入队
        }
    }
}


//Floyd算法(代码仅了解)——使用动态规划思想，将问题的求解分为多个阶段

    //多级矩阵A——存储各个结点间的最短路径，每增加一个中转点则更新为下一级的矩阵
    //path矩阵——存储各结点最短路径上的前驱(中转点)
    //准备工作，根据图的信息初始化矩阵A和path
for(int k=0;k<n;k++){                       //考虑以Vk作为中转点
    for(int i=0;i<n;i++){                   //遍历整个矩阵，i为行，j为列
        for(int j=0;j<n;j++){
            if(A[i][j]>A[i][k]+A[k][i]){   //若以Vk作为中转点路径更短
                A[i][j]=A[i][k]+A[k][i];    //更新最短路径长度
                path[i][j]=k;               //更新中转点
            }
        }
    }
}

//Tips：该算法代码看似简单，但其实有叠加效应——前面已经处理过的中转点得到的新最短路径可为后面的中转点所使用
//可通过path矩阵递归找到完整路径
```
* 有向无环图(**DAG图**)——描述含有公共子式的表达式的有效工具

* 拓扑排序与逆拓扑排序
  * 拓扑排序
    1. 从**AOV网**中选择一个入度为0(没有前驱)的顶点输出
    2. 从网中删除该顶点和所有以它为起点的有向边
    3. 重复1和2，直到~~AOV网为空~~或~~当前网中不存在入度为0的顶点(说明一定有环)~~
  * 逆拓扑排序
    1. 从AOV网中选择一个出度为0(没有后继)的顶点输出
    2. 从网中删除该顶点和所有以它为终点的有向边
    3. 重复1和2，直到AOV网为空

* 关键路径与**AOE网**

```c
//拓扑排序
//建立一个工作栈:S 顺序输出每次处理后的入度为0的顶点
//建立两个数组:1.indegree[G.vexnum]表示某顶点的入度
//            2.print[G.vexnum]表示输出的拓扑序列
//变量p为边结点类型


bool TopologicalSort(Graph G){
    InitStack(S);               //初始化栈
    for(int i=0;i<G.vexnum;i++) //将所有入度为0的顶点入栈
        if(indegree[i]==0)
            Push(S,i);
    int count=0;//计数，记录当前已经输出的顶点数
    while(!IsEmpty(S)){
        Pop(S,i);               //输出栈顶元素
        print[count++]=i;       //输出顶点i
        for(p=G.vertices[i].firstarc;p;p=p->nextarc){   //将i指向的所有顶点的入度-1，并将入度减为0的顶点压入栈
            v=p->adjvex;
            if(!(--indegree[v]))    //对当前邻接点的入度进行逻辑删除(实际上图中该结点入度并未改变)
                Push(S,v);
        }
    }//while
}
if(count<G.vexnum)
    return false;   //排序失败，表明有向图中有回路
else
    return true;
```

## 查找
### 顺序查找
用于~~顺序表~~或~~链表~~
```c
typedef struct{
    ElemType *elem; //元素存储空间基址，注意空指针问题(应分配地址)
    int TableLen;   //表的长度
}SSTable;
int Search_Seq(SSTable ST,ElemType key){
    ST.elem[0]=key;//哨兵
    int i;
    for(i=ST.TableLen;ST.elem[i]!=key;i--);
    return i;   //i为0表示未找到相关元素，否则查找成功
}
```

### 折半查找
用于~~有序的顺序表~~
```c
//折半查找
int Binary_Search(SeqList L,ElemType key){
    int low=0,high=L.TabLen-1,mid;
    while(low<=high){           //小心判断条件
        mid=(low+high)/2;       //取中间位置，注意此处会对非整数截断，造成向下取整
        if(L.elem[mid]==key)
            return mid; //查找成功时，返回该位置(即mid)
        else if(L.elem[mid]>key)
            high=mid-1; //从前半部分开始查找
        else //相当于判断L.elem[mid]<key
            low=mid+1;  //从后半部分开始查找
    }

    return -1;          //执行完上述循环还没返回，则说明未找到该元素
}
```

### 分块查找
```c
//分块结构定义  分块结构特点：块内可以无序，块间必须有序

//索引表
typedef struct{
    ElemType maxValue;  //最大关键字
    int low,high;       //当前索引表的元素所处的分块区间范围(数组下标的范围)
}Index;

//用顺序表存储实际元素
ElemType List[100];
```
### 二叉排序树(树形查找)
> 二叉排序树查找

```c
//非递归实现，时间复杂度O(1)
BSTNode *BST_Search(BiTree T,ElemType key){
    while(T!NULL && key!=T->data){  //树空(表明没有该值)或找到该值，则退出循环
        if(key < T->data)   //小于，则在左子树上查找
            T=T->lchild;
        else                //大于，则在右子树上查找
            T=T->rchild;
    }
    return T;   //已经包含了查找失败的情况(返回空指针)
}

//递归实现，时间复杂度O(n^2)

```

> 二叉排序树插入

```c
int
```

> 二叉排序树构造

```c

```
> 二叉排序树删除

注意可能出现的三种情况
1. 被删除结点z为叶节点
2. z只有左子树或者右子树
3. z既有左子树又有右子树

```c

```

### 平衡二叉树
> 平衡二叉树结点(了解)

```c
typedef struct AVLNode{
    int key;        //数据域
    int balance;    //平衡因子
    struct AVLNode *lchild,*rchild;
}AVLNode,*AVLTree;
```
* 平衡二叉树的插入
* 平衡二叉树的删除

### 红黑树

> 红黑树结点

```c
struct RBnode{
    int key;        //关键字的值
    RBnode *parent; //父节点
    RBnode *lchild;
    RBnode *rchild;
    int color;      //结点颜色，可用enum、bool等表示
}
```

### B树
### B+树

### 散列查找

## 排序
### 插入排序
```c
//直接插入排序
void InsertSort(ElemType A[],int n){
    int i,j;
    ElemType temp;
    for(i=2;i<n;i++){           //将各元素插入已排好序的序列中
      if(A[i]<A[i-1]){          //如果当前扫描值A[i]小于前驱
            temp=A[i];
            for(j=i-1;j>=0 && A[j]>A[i];j--)//检查前面已排好序的元素，所有大于A[i]的元素都将向后挪1位(退出循环时，j应指向从后往前，第一个等于或小于A[i]的值)
                A[j+1]=A[j];
            A[j+1]=temp;        //将扫描值插入找到的位置
        }
    }
}

//折半插入排序
void InsetSort(ElemType A[],int n){
    int i,j,low,high,mid;
    ElemType temp;
    for(i=1;i<n;i++){
        low=0;high=i-1;
        while(low<=high){       //折半查找，注意：low=high时，仍要进行一轮比较
            mid=(low+high)/2;
            if(A[mid]>A[i])
                high=mid-1;
            else
                low=mid+1;
        }
            //最终mid所指向的位置可能是小于、等于、大于A[i]的元素
            //注意：而high指向的位置为一定是最后一个等于或最后一个小于A[i]的元素
            //        low指向的位置一定是第一个大于或最后一个等于A[i]的元素(即high+1)
        temp=A[i];
        for(j=i-1;j>=high+1;j--)//统一后移元素，空出插入位置
            A[j+1]=A[j];    
        A[high+1]=temp;
    }
}

//希尔排序
void ShellSort(ElemType A[i],int n){
    int i,j,d;
    d=n;
    ElemType temp;
    for(d=n;d>=1;d=d/2){//步长变化
        for(i=d+1;i<n;i++){
            if(A[i]<A[i-d]){//仅当A[i]的值小于前驱时，才需要进行插入
                temp=A[i];
                for(j=i-d;j>=0 && A[j]>A[i];j-=d){    //注意i前面的元素是已经排好序的
                    A[j+d]=A[j];    //将i前面大于A[i]的元素后移
                }
                //最后j指向最后一个小于或最后一个等于A[i]的元素，也可能指向一个非法值
                A[j+d]=temp;
            }
        }
    }
}
```

### 交换排序
```c
//冒泡排序
void swap(ELemType &a,ElemType &b){
    ELemType temp=a;
    a=b;
    b=temp;
}

void BublleSort(ElemType &A[],int n){
    int i,j;    //i表示已经排号序的列表后的第一个元素
    bool Flag;//表示本趟冒泡是否发生交换位置，若否，应该直接结束排序
    for(i=0;i<n;i++){
        Flag=false;
        for(j=n-1;j>i;j--){     //一趟冒泡过程
            if(A[j]<A[j-1])     //若元素为逆序，则交换位置，并修改交换标志
                swap(A[j],A[j-1]);
                flag=true;
        }

        if(Flag==false)
            return;
    }
}


//快速排序
int Partition(ElemType &A[],int low,int high){
    ElemType pivot=A[low];//将该层枢轴设置为传下来的子表的第一个元素
    while(low<high){
        while(A[high]>pivot && low<high) high--;//注意：也判断low和high
        //此时high一定找到一个小于pivot的值
        A[low]=A[high]; //将比枢轴小的元素移动到左边
                        //high已交换过去，该位置等待插入下一个大于pivot的值
        while(A[low]<pivot && low<high) low++;
        //此时low一定找到一个大于pivot的值
        A[high]=A[high];
    }
    A[low]=pivot;
    ruturn low;//返回枢轴的最终位置
}
void QuickSort(ElemType &A[],int low,int high){
    if(low<high){
        int pivotpos=Partition(A,low,high);//划分，pivotpos记录当前层递归应使用的枢轴
        QuickSort(A,low,pivotpos-1);  //依次对两个子表进行递归排序
                                        //注意：是对当前函数进行递归
        QuickSort(A,pivotpos+1,high); 
    }
}
/*
Tips：(个人理解)
    1.为保证递归逻辑顺利，尽量将递归函数，及其引用的函数的形参统一
    2.每次递归时，注意传入的形参，应该是下一级递归要使用的，每层递归声明的变量仅能用于该层递归，与其他层递归的同名变量是不同的
    3.设计递归函数时，要考虑下一层递归要传入的形参，要执行的操作顺序，对最底层递归结束条件的设计，是否有返回值(返回值是返回给上一层递归的，要考虑其在上一层递归该怎么使用)
    4.写好引用的函数后，在递归体使用引用的函数时，不要去考虑该函数的实现，而是直接利用该函数的功能来完成目的

优化方案：
    1.尽量选取一个可以将数据中分的枢轴元素
    2.随机从表中选取枢轴元素
*/

```

### 堆排序
* 大根堆：最大元素存放于**根节点**，任一非根节点都小于等于其双亲的值
* 小根堆：与大根堆相反

```c
//明确处理方案：    1.先将待排数列变成大根堆
//                 2.从后往前循环处理堆的最后一个结点
//                    每次将根节点(值最大的)与堆的最后一个元素互换(不包括已经换到最后的元素)
//                    互换后重新调整为大根堆

void HeadAdjust(ElemType &A[],int k,int len){   //将数组调整为大根堆
    A[0]=A[k];
    int i=k*2;                              //i表示当前扫描结点k的最大孩子
    for(;i<=len;i*=2){                    //循环的作用实际是将大于传入的根A[0]的孩子上移，寻找A[0]的插入位置
                //                          当i>len说明当前处理的k已无孩子，应退出
        if(i<=len && A[i]<A[i+1])   i++;   //将i指向k最大的孩子

        if(A[0]>=A[i])   break;  //A[0]存储的原k的值，若大于当前扫描结点k(实际上k所指结点>A[0]，已经上移到其父节点)的孩子，说明此处即为插入位置应退出
        else{
            A[k]=A[i];  //将更大的值i复制到到其父节点k
            k=i;        //上移结点的原位置插入A[0]可能导致不符合大根堆，应继续处理原k结点的子树
            //此时i会递增为i*2，即现在k的左孩子
        }
    }
    //经以上步骤，k应指向一个值大于原k(即A[0],并且当前结点已经上移到其父节点，
        //且其孩子满足A[0]的插入(即孩子小于原k的值)，该处即为原k值A[0]的插入点
    A[k]=A[0];
}

void BuildMaxHeap(ElemType &A[],int len){      //建立大根堆
    for(int i=len/2;i>1;i--)    //从最小的非叶节点开始，循环调整各非叶结点(i<len/2时，是非叶节点)为大根堆
    //                              注意：此处容易直接用HeadAdjust调整A[1],只对第一个元素调整不能调出大根堆
                                //  因为有的最大结点可能只会被往上调一级，不会被调到根，
                                //  而且为了保证最大值会调整到跟，应该最后对根进行调整
        HeadAdjust(A[],i,len);
}

void HeapSort(ElemType A[],int len){
    BuildMaxHeap(A,len);        //构建大根堆
    for(int i=len;i>1;i--){     //从后到前处理n-1趟
        swap(A[1],A[i]);        //每次将大根堆根节点(堆中的即最大值)放到堆尾
        HeapAdjust(A,1,i-1);    //将交换后的堆(不包括刚交换的后面的结点)重新调整为大根堆
    }
}
```
### 归并排序
```c
//2路归并排序
ElemType *B=(ElemType *)malloc(sizeof(ElemType)*(n+1)); //辅助数组B

int Merge(ElemType &A[],int low,int mid,int high){      //归并操作：合并两个有序表
    for(int k=low;k<high;k++){                          //将要处理的表A复制到B
        B[k]=A[k];
    }

    for(int i=mid,j=mid+1,k=i;i<=mid && j<=high;k++){   //依次从两表中摘取小的值到原表中
        if(B[i]<=B[j]) A[k]=B[i++]; //i扫描左子表，j扫描右子表，k用于统计已经排号序的元素(方便最后处理剩余元素)
        else    A[k]=B[j++]; 
    }
    while(i<=mid)  A[k]=B[i++];     //处理剩余的子表元素
    while(j<=high)  A[k]=B[j++];
}

void MergeSort(ElemType &A[],int low,int high){
    if(low<high){       //递归退出条件，当传入的low>=high，表示已经到最下层的结点
        /*  明确目的：递归到最深层，再依次返回上一层，返回前要先把该层的任务处理好
            每层的引用函数需要用到low，high，mid，和A，
            而low、high、mid需要由主函数传入
            可是low和high、mid在最每层应由上一层递归传入
            传入的low和high应该有所改变
                可参考二叉树的递归遍历，先不断将表一分为二，直到最下层结点，最后再做处理
                这样返回上一层的时候，下层已经处理好了，正好又进行该层的处理，故考虑从mid入手
            每次递归取mid为传入low、high的中间值，即可实现分为两个子表
            为了定位到最深一层递归，应该对比两个元素
                对于mid所在的表(左边)，下一次递归应该将mid传给下一层的high
                对于mid右边的表，下一次递归应将mid+1作为low传入下一层
            故mid才要在每一层递归中改变才行
            取low和high中间的元素为mid
                (不用考虑各mid是否在有序表中值元素，因为从最深层递归进行Merge时
                可将两两元素按顺序排好序，成为多个有序表哦，然后才在上层递归中处理下层递归处理好的有序表)
            */
        int mid=(low+high)/2;     //每层递归都在该层传入的数组中找一个mid来划分左右子表
        MergeSort(A,low,mid);     //递归处理左子表
        MergeSort(A,mid+1,high);  //递归处理右子表
        Merge(A,low，mid,high);   //归并：处理最终得到的左右子表(已有序)
    }
}
```



